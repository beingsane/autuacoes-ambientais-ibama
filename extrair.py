#!/usr/bin/env python3
import re

import rows
from rows.plugins.utils import create_table


class BRMoneyField(rows.fields.DecimalField):
    """DecimalField which decodes from Brazilian format"""

    @classmethod
    def deserialize(cls, value):
        value = (value or '').replace('.', '').replace(',', '.').strip()
        return super().deserialize(value)


class BRDateField(rows.fields.DateField):
    """DateField which decodes from Brazilian format"""

    INPUT_FORMAT = '%d/%m/%Y'


def fix_rows(data, header=False):
    """Fix rows returned by the PDF table extraction algorithm

    - Delete repeated headers (pages 2+)
    - Remove empty rows
    - Split colum 4 into 4 and 5 when needed (the content of these cells
      sometimes are nested into one object)
    - Split colum 5 into 5 and 6 when needed (the content of these cells
      sometimes are nested into one object)
    """

    data = list(data)
    if data[0][0] == 'Nº' and not header:
        data = data[1:]

    result = []
    for row in data:
        row = [value.replace('\n', ' ').strip() if value is not None else None
               for value in row]

        if not any(row):  # empty row
            continue
        elif ' ' in (row[5] or ''):
            # Fix wrong row:
            #     [..., 'doc name', None, ...] -> [..., 'doc', 'name', ...]
            start = row[5].find(' ')
            row[5], row[6] = row[5][:start], row[5][start + 1:]
        elif row[5] is None and len(re.findall('[0-9]', row[4] or '')) in (11, 14):
            # Fix wrong row:
            #     [..., 'city doc', None, ...] -> [..., 'city', 'doc', ...]
            start = row[4].rfind(' ')
            row[4], row[5] = row[4][:start], row[4][start + 1:]

        result.append(row)
    return result


def extract_ibama_pdf(filename):
    """Extract all pages from a "Autuação Ambiental" PDF, generated by IBAMA

    This function will extract each page at once so we can use rows'
    `starts_after/ends_before`.
    It's using `pdf_table_lines` instead of `import_from_pdf` because it's
    faster and we can fix the table lines before importing data as a
    `rows.Table`.
    """

    final = []
    total_pages = rows.plugins.pdf.number_of_pages(filename)
    for page_number in range(1, total_pages + 1):
        print('Processing page {}...'.format(page_number))
        with open(filename, mode='rb') as fobj:
            table_rows = rows.plugins.pdf.pdf_table_lines(
                fobj,
                page_numbers=(page_number,),
                starts_after='DIRETORIA DE PROTEÇÃO AMBIENTAL',
                ends_before=re.compile('Pag [0-9]+/[0-9]+'),
                algorithm='rects-boundaries',
            )
            final.extend(fix_rows(table_rows, header=page_number == 1))

    table = create_table(
        final,
        meta={'imported_from': 'pdf', 'filename': filename},
        force_types={'data_infracao': BRDateField, 'valor_multa': BRMoneyField}
    )
    return table


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('input_filename')
    parser.add_argument('output_filename')
    args = parser.parse_args()

    table = extract_ibama_pdf(args.input_filename)
    rows.export_to_csv(table, args.output_filename)
